#!/usr/bin/env perl
# arrangeProject
use strict;
use warnings;
use feature 'say';
use autodie;
use Cwd qw(abs_path getcwd);
use File::Path qw(make_path remove_tree);
use File::Copy;
use File::Find;
use Switch;
use Getopt::Long;
use IO::Dir;

my $usage = << "EOU";

Synopsis:

    arrangeProject --run

Description:

    arrangeProject will create all the needed UGP directories, 
    and move all files into their proper locations.

    * Must be ran from the directory created by createProject *
    * or the config file output directory. *

Required options:

    --run, -r   :   Allow arrangeProject to begin.

Additional options:

    -dir, -d    :   Directory to run arrangeProject in. [default: current]
    -help, -h   :   This usage statement.                                    

EOU

## exit on help statement
my %c_opts = ();
GetOptions( 
    \%c_opts, 
    "run|r",
    "dir|d=s",
    "help|h"
);
die $usage if $c_opts{help};
die $usage unless ($c_opts{run});

my $dir = getcwd;
my (@gvcfs, @bams, @finalVCF, @logFiles, @reports, @trashCan, @snpeff, @flagstat, @fcounts, @stats);
finddepth(
    sub {
        no warnings;
        return if ( $_ eq '.' || $_ eq '..' );
        my $file = $_;

        if (-l $file) {
            push @trashCan, $file;
            next;
        }
        if ( $file =~ /^chr/ ) {
            push @trashCan, abs_path($file);
            next;
        }
        if ( $file =~ /(csv$|genes|snpEff_summary.html|ann)/ ) {
            push @snpeff, abs_path($file);
            next;
        }
        if ( $file =~ /flagstat/ ) {
            push @flagstat, abs_path($file);
            next;
        }
        if ( $file =~ /fcounts/ ) {
            push @fcounts, abs_path($file);
            next;
        }
        if ( $file =~ /stats/ ) {
            push @stats, abs_path($file);
            next;
        }
        if ( $file =~ /(g.vcf$|g.vcf.idx$)/ ) {
            push @gvcfs, abs_path($file);
            next;
        }
        if ( $file =~ /(bam$|bam.bai$)/) {
            push @bams, abs_path($file);
            next;
        }
        if ( $file =~ /(FQF-.*vcf.gz$|FQF-.*vcf.gz.tbi$)/ ) {
            push @finalVCF, abs_path($file);
            next;
        }
        if ( $file =~ /(FQF_Pipeline.*-log.txt)/ ) {
            push @logFiles, abs_path($file);
            next;
        }
        if ( $file =~ /(pdf|multiqc)/ ) {
            push @reports, abs_path($file);
            next;
        }
        else {
            push @trashCan, abs_path($file);
        } 
    },
    $dir
);

## ----------------------------
## create the needed directories
say "Building needed directories...";
make_path(
    'Analysis',
    'Data/PolishedBams',     'Data/Primary_Data',
    'Reports/RunLogs',       'Reports/fastqc',
    'Reports/flagstat',      'Reports/stats',
    'Reports/featureCounts', 'Reports/SnpEff',
    'VCF/Complete',          'VCF/GVCFs',
    'VCF/WHAM', 
    'trashcan'
);

## Move the collections into correct directory.
say "Moving data into correct directory structure...";
map { move( $_, 'VCF/GVCFs') } @gvcfs;
map { move( $_, 'Data/PolishedBams') } @bams;
map { move( $_, 'VCF/Complete') } @finalVCF;
map { move( $_, 'Reports/RunLogs') } @logFiles;
map { move( $_, 'Reports') } @reports;
map { move( $_, 'trashcan') } @trashCan;
map { move( $_, 'Reports/SnpEff') } @snpeff;
map { move( $_, 'Reports/flagstat') } @flagstat;
map { move( $_, 'Reports/featureCounts') } @fcounts;
map { move( $_, 'Reports/stats') } @stats;

## clean up empty directories.
say "Cleaning up empty directories...";
remove_empty_dirs($dir);

say "Finished!";

## ----------------------------------------------------- ##

sub remove_empty_dirs {
    my $dir = shift;

    opendir( my $DIR, $dir ) or warn "Could not open abs_directory $dir";

    finddepth( sub {
        next if ( $_ eq '.' || $_ eq '..' );
        
       my $oio; 
        
        
        }, );







    my $count;
    foreach my $file ( readdir $DIR ) {
        next if ( $file eq '.' || $file eq '..' );
        $count++;
        my $abs_file = abs_path($file);
        if ( -d $abs_file ) {

            my $klklk;
            remove_empty_dirs($abs_file);
        }
    }
    if ( !$count ) {
        say "remove abs_dir: $dir";
        rmdir $dir;
    }
}

## ----------------------------------------------------- ##

