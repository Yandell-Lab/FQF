#!/usr/bin/env perl
# arrangeProject
use strict;
use warnings;
use feature 'say';
use autodie;
use Cwd qw(abs_path getcwd);
use File::Path qw(make_path remove_tree);
use File::Copy;
use File::Find;
use Switch;
use Getopt::Long;
use IO::Dir;

my $usage = << "EOU";

Synopsis:

    arrangeProject --run

Description:

    arrangeProject will create all the needed UGP directories, 
    and move all files into their proper locations.

    * Must be ran from the directory created by createProject *
    * or the config file output directory. *

Required options:

    --run, -r   :   Allow arrangeProject to begin.

Additional options:

    -dir, -d    :   Directory to run arrangeProject in. [default: current]
    -help, -h   :   This usage statement.                                    

EOU

## exit on help statement
my %c_opts = ();
GetOptions( 
    \%c_opts, 
    "run|r",
    "dir|d=s",
    "help|h"
);
die $usage if $c_opts{help};
die $usage unless ($c_opts{run});

## --------------------
## collect unneeded files.
my @remove_types = (
    "chr",
    "combined",
    "genotyped",
    "file.list",
    "theVoid",
    "cat_recal",
    "_indel_tranches",
    "_indel_recal",
    "_snp_recal",
    "_plots.R",
    "cfg",
    "PROGRESS",
    "WARN.txt",
    "FATAL.txt",
    "wham.vcf.log",
    "fastq\$",
    "genotype.wham.vcf\$",
);

my $dir = getcwd;
my @to_rm;
finddepth(
    sub {
        return if ( $_ eq '.' || $_ eq '..' );
        foreach my $type (@remove_types) {
            if ( $_ =~ /$type/ ) {
                push @to_rm, abs_path($_);
            }
        }
    },
    $dir
);

## now remove files and directories.
say "Cleaning up trash...";
foreach my $trash (@to_rm) {
    if ( -f $trash ) {
        unlink $trash;
    }
    elsif ( -d $trash ) {
        remove_tree($trash);
    }
}

## ----------------------------
## create the needed directories
say "Building needed directories...";
make_path(
    'Analysis',
    'Data/PolishedBams',     'Data/Primary_Data',
    'Reports/RunLogs',       'Reports/fastqc',
    'Reports/flagstat',      'Reports/stats',
    'Reports/featureCounts', 'Reports/SnpEff',
    'VCF/Complete',          'VCF/GVCFs',
    'VCF/WHAM',
);

## list of all the file types to collect.
## maintain order
my @kept_file_types = (
    "fastq.gz",
    "DNA.*bam",
    "bam\$",
    "bam.bai\$",
    "fastqc",
    "flagstat",
    "stats",
    "ann",
    "fcounts",
    "wham",
    "g.vcf",
    "-log.txt",
    "FQF-.*gz",
    "FQF-.*idx",
    "FQF-.*tbi",
    "snpEff_summary.html",
    "multiqc.report.html",
    "pdf",
    "csv",
    "genes.txt",
);

## find each type and move.
my %type_match;
say "Moving file types into correct directories...";
finddepth(
    sub {
        return if ( $_ eq '.' || $_ eq '..' );
        foreach my $type (@kept_file_types) {
            if ( $_ =~ /$type/ ) {
                push @{$type_match{$type}}, abs_path($_);
            }
        }
    },
    $dir
);

## move kept file to correct location.
foreach my $found (keys %type_match) {
    location_mv($found, $type_match{$found});
}

## clean up empty dir and finish.
dir_cleanup($dir);
say "Finished!";

## ----------------------------------------------------- ##

sub dir_cleanup {
    my $dir = shift;

    my $DIR = IO::Dir->new($dir);
    my $file_count;
    foreach my $file ( readdir $DIR ) {
        next if ( $file eq '.' || $file eq '..' );
        # get stragglers.
        if ( $file =~ /tranches$/ ) {
            unlink $file;
        }
        $file_count++;
        if ( -d $file ) {
            dir_cleanup(abs_path($file));
        }
    }
    if ( !$file_count ) {
        rmdir $dir;
    }
}

## ----------------------------------------------------- ##

sub location_mv {
    my ($type, $to_mv) = @_;
    my @to_mv = @{$to_mv};

    ## maintain order
    switch ($type) {
        case /(genes.txt|csv|ann|snpEff_summary.html)/ {
            map { move( $_, 'Reports/SnpEff') } @to_mv;
        }
        case /-log.txt/ {
            map { move( $_, 'Reports/RunLogs' ) } @to_mv;
        }
        case /fcounts/ {
            map { move( $_, 'Reports/featureCounts' ) } @to_mv;
        }
        case /fastq.gz/ {
            map { move( $_, 'Data/Primary_Data' ) } @to_mv;
        }
        case /DNA.*bam/ {
            map { move( $_, 'Data/Primary_Data' ) } @to_mv;
        }
        case /bam/ {
            map { move( $_, 'Data/PolishedBams' ) } @to_mv;
        }
        case /flagstat$/ {
            map { move( $_, 'Reports/flagstat' ) } @to_mv;
        }
        case /stats$/ {
            map { move( $_, 'Reports/stats' ) } @to_mv;
        }
        case /g.vcf/ {
            map { move( $_, 'VCF/GVCFs' ) } @to_mv;
        }
        case /fastqc/ {
            map { move( $_, 'Reports/fastqc' ) } @to_mv;
        }
        case /(FQF-.*tbi|FQF-.*gz|FQF-.*idx)/ {
            map { move( $_, 'VCF/Complete' ) } @to_mv;
        }
        case /(pdf|multiqc.report.html)/ {
            map { move( $_, 'Reports/' ) } @to_mv;
        }
        case /wham/ {
            map { move( $_, 'VCF/WHAM' ) } @to_mv;
        }
    }
}

## ----------------------------------------------------- ##

